#!/usr/bin/env python
import rospy
import yaml
import numpy as np
from matplotlib import pyplot as plt
#
from nav_msgs.msg import (
    OccupancyGrid,
)
from map_msgs.msg import (
    OccupancyGridUpdate,
)


# Extra utility functions
# import utility as utl



class COSTMAP_LISTENER(object):
    """
    This is the class for costmap_listener, where the costmap is generated by another node and published by topics.
    """
    def __init__(self, param_dict):
        """
        inputs
            - param_dict

        The param_dict should include the following fields:
        - costmap_topic_name
        """
        # Get parameters from param_dict
        self.costmap_topic_name = param_dict.get('costmap_topic_name', "/occupancy_grid_wayarea") # or, "/move_base/global_costmap"

        # Parameters
        # Special values
        self.special_values_occupied_threshold = 50
        self.special_values_free = 0


        # States
        self.costmap_initiated = False # **[This flag will be updated only once.]** The original costmap should be loaded first before we can start updating
        self.costmap_updated = False
        #
        self.update_stamp = None
        self.costmap_frame = None
        self.costmap_info = None
        """
        info:
            - map_load_time
            - resolution
            - width
            - height
            - origin
        """
        self.costmap_shape = np.array((0,0))
        self.origin_point2D = np.array((0,0)) # shape = (2,). There's no need to get the orientation, since it's always be 0 deg.
        # This is the data of costmap, shape=(height, width)
        self.costmap = np.zeros((1,1))


        # ROS subscriber
        rospy.Subscriber(self.costmap_topic_name, OccupancyGrid, self._costmap_CB)

        self.im_show_h = None


    def _costmap_CB(self, data):
        """
        This is the callback function for costmap.
        """
        self.update_stamp = data.header.stamp
        self.costmap_frame = data.header.frame_id
        self.costmap_info = data.info
        self.costmap_shape = np.array( (data.info.height, data.info.width) ) # (height,width); height for y-direction, width for x-direction, like image
        self.origin_point2D = np.array( (data.info.origin.position.x, data.info.origin.position.y) ) # shape = (2,). There's no need to get the orientation, since it's always be 0 deg.
        # print self.costmap_info
        #
        # costmap_array = np.array(data.data, dtype=int)
        self.costmap = np.array(data.data, dtype=int).reshape(self.costmap_shape)
        # Note: the (0,0) is the point closest to the origin.
        if not self.costmap_updated:
            self.costmap_updated = True
        #
        if not self.costmap_initiated:
            self.costmap_initiated = True


    def _get_point2D_from_index2D(self, index2D):
        """
        This function return the point2D from the given index2D.
        inputs
            - index2D: (m in row, n in col) <-- (y,x), 0-indexed
        outputs
            - point2D: (x,y), shape=(2,), 1-D array,
                      ** Note: it's not pose2D, which is a 3x1 2-D array.
        """
        # We cannot calculate until we got the full costmap
        if not self.costmap_initiated:
            return None

        index2D_np = np.array(index2D).reshape((2,))
        # Get the point2D: (x, y) from (m,n), 0-indexed
        # First flip the order in index
        # Then shift to the center of a cell by adding 0.5
        # Change to the correct unit by multiplying resolution
        # Shift to the refeerence frame by adding the origin of the costmap
        return ( self.origin_point2D + ( index2D_np[::-1,].astype(float) + 0.5 )*self.costmap_info.resolution )

    def _get_index2D_from_point2D(self, point2D, is_checking_bound=True):
        """
        This function return the index2D from the given pose2D.
        inputs
            - point2D: (x,y), shape=(2,), 1-D array,
                      ** Note: it's not pose2D, which is a 3x1 2-D array.
        outputs
            - index2D: (m in row, n in col) <-- (y,x), 0-indexed
                      ** Note: The returned index2D might be out of the bound of the costmap!!
                               The reason for returning an invalid index is for calculating a line toward the bound.
        """
        # We cannot calculate until we got the full costmap
        if not self.costmap_initiated:
            return None

        try:
            resolution_inv = 1.0/(self.costmap_info.resolution) # cell/m
        except:
            # self.costmap_info.resolution is zero
            rospy.logerr("[Costmap-listener] Resolution is 0.")
            return None
        point2D_np = np.array(point2D).reshape((2,))
        # Get the index2D: (m, n) from (x,y), 0-indexed
        # First calculate the relative position
        # Then digitalized, including unit-change, floor-rounding, and converting to "int"
        # The last commad help flip the array in first dimension, so that we get the order in (m,n)
        index2D_np = np.floor((point2D_np - self.origin_point2D)*resolution_inv).astype(int)[::-1,]

        if is_checking_bound:
            if (np.sum(index2D_np < 0) > 0) or (np.sum(index2D_np >= self.costmap_shape) > 0):
                # out of bound
                rospy.logwarn("[Costmap-listener] The point queried is out of bound.")
                return None
                # Simply warning, still return an invalid index
            #
        #
        return index2D_np


    def plot_costmap(self, show_obstacle_only=False):
        """
        This function help plot the costmap with pyplot
        """
        # Flip the image for maching the image coordinate convention!

        if show_obstacle_only:
            Cmap_H = np.flipud(self.costmap)>=100
        else:
            Cmap_H = np.flipud(self.costmap)
        #
        Cmap_H_90 = np.rot90(Cmap_H)
        #
        if self.im_show_h is None:
            self.im_show_h = plt.imshow(Cmap_H_90, cmap = 'gray', interpolation = 'nearest')
        else:
            self.im_show_h.set_data(Cmap_H_90)
        # plt.show(block = False)
        plt.draw()
        plt.pause(0.001)





def costmap_listener():
    # Init. node
    rospy.init_node('costmap_listener', anonymous=True)

    costmap_topic_name = "/occupancy_grid_wayarea"
    # costmap_topic_name = "/move_base/global_costmap"


    param_dict = dict()
    param_dict['costmap_topic_name'] = costmap_topic_name
    #
    costmap_L = COSTMAP_LISTENER(param_dict)


    rate = rospy.Rate(20) # 20hz
    while not rospy.is_shutdown():
        #
        if costmap_L.costmap_updated:
            # print("costmap_updated")
            costmap_L.plot_costmap(show_obstacle_only=False)
            costmap_L.costmap_updated = False
        #
        rate.sleep()


if __name__ == '__main__':
    costmap_listener()
